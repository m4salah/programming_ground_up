#PURPOSE: THIS PROGRAM CONVERTS AN INPUT FILE
#	  TO AN OUTPUT FILE WITH ALL LETTERS 
#	  CONVERTED TO UPPERCASE.
#
#PROCESSING: 1) OPEN THE INPUT FILE
#	     2) OPEN THE OUTPUT FILE
#	     3) WHILE WE'RE NOT AT THE END OF THE INPUT FILE
#		A) READ PART OF FILE INTO OUR MEMORY BUFFER
#		B) GO THROUGH EACH BYTE OF MEMORY
#			IF THE BYTE IS LOWERCASE LETTER,
#			CONVERT IT TO UPPERCASE
#		C) WRITE THE MEMORY BUFFER TO OUTPUT FILE

.SECTION .DATA

########CONSTANTS########

#SYSTEM CALL NUMBERS (64-BIT)
.EQU SYS_READ, 0
.EQU SYS_WRITE, 1
.EQU SYS_OPEN, 2
.EQU SYS_CLOSE, 3
.EQU SYS_EXIT, 60

#OPTIONS FOR OPEN
.EQU O_RDONLY, 0
.EQU O_CREAT_WRONLY_TRUNC, 03101

#STANDARD FILE DESCRIPTORS
.EQU STDIN, 0
.EQU STDOUT, 1
.EQU STDERR, 2

.EQU END_OF_FILE, 0		#RETURN VALUE OF READ WHEN END OF FILE
.EQU NUMBER_ARGUMENTS, 2

.SECTION .BSS
#BUFFER - DATA FROM INPUT FILE LOADED INTO, 
#	  CONVERTED TO UPPERCASE AND WRITTEN
#	  TO OUTPUT FILE
.EQU BUFFER_SIZE, 500
.LCOMM BUFFER_DATA, BUFFER_SIZE	#CREATES BUFFER CALLED BUFFER_DATA
				#WITH SIZE OF 500 BYTES.

.SECTION .TEXT

#STACK POSITIONS (64-BIT OFFSETS)
.EQU ST_SIZE_RESERVE, 16	#RESERVE SPACE FOR 2 QUADWORDS
.EQU ST_FD_IN, -8		#INPUT FILE DESCRIPTOR
.EQU ST_FD_OUT, -16		#OUTPUT FILE DESCRIPTOR
.EQU ST_ARGC, 0			#NUMBER OF ARGUMENTS
.EQU ST_ARGV_0, 8		#NAME OF PROGRAM (64-BIT POINTERS)
.EQU ST_ARGV_1, 16		#INPUT FILE NAME
.EQU ST_ARGV_2, 24		#OUTPUT FILE NAME

.GLOBL _START
_START:

####INITIALIZE PROGRAM#####
#SAVE STACK POINTER
MOV %RSP, %RBP

# ALLOCATE SPACE FOR FILE DESCRIPTORS ON THE STACK
SUB $ST_SIZE_RESERVE, %RSP	#2 QUADWORDS

OPEN_FILES:
OPEN_FD_IN:			#OPEN INPUT FILE
MOV $SYS_OPEN, %RAX		#SYSTEM CALL NUMBER FOR OPEN
MOV ST_ARGV_1(%RBP), %RDI	#FILENAME (FIRST ARGUMENT IN RDI)
MOV $O_RDONLY, %RSI		#FLAGS (SECOND ARGUMENT IN RSI)
MOV $0666, %RDX		#MODE (THIRD ARGUMENT IN RDX)
SYSCALL				#64-BIT SYSTEM CALL

STORE_FD_IN:
MOV %RAX, ST_FD_IN(%RBP)	#STORE FILE DESCRIPTOR

OPEN_FD_OUT:
MOV $SYS_OPEN, %RAX
MOV ST_ARGV_2(%RBP), %RDI	#OUTPUT FILENAME
MOV $O_CREAT_WRONLY_TRUNC, %RSI
MOV $0666, %RDX
SYSCALL

STORE_FD_OUT:
MOV %RAX, ST_FD_OUT(%RBP)	#STORE FILE DESCRIPTOR

READ_LOOP_BEGIN:
MOV $SYS_READ, %RAX		#READ SYSTEM CALL
MOV ST_FD_IN(%RBP), %RDI	#FILE DESCRIPTOR (FIRST ARGUMENT)
MOV $BUFFER_DATA, %RSI		#BUFFER LOCATION (SECOND ARGUMENT)
MOV $BUFFER_SIZE, %RDX		#BUFFER SIZE (THIRD ARGUMENT)
SYSCALL				#SIZE OF BUFFER READ IS RETURNED TO %RAX

#EXIT IF WE HAVE REACHED THE END
CMP $END_OF_FILE, %RAX		#CHECK FOR THE END OF FILE MARKER
JLE END_LOOP			#IF FOUND OR ON ERROR, GO TO END

CONTINUE_READ_LOOP:
#CONVERT THE BLOCK TO UPPERCASE
PUSH %RAX
MOV %RAX, %RDI			#FIRST ARGUMENT: BUFFER SIZE
MOV $BUFFER_DATA, %RSI		#SECOND ARGUMENT: BUFFER LOCATION
CALL CONVERT_TO_UPPER		#CALL CONVERSION FUNCTION

#WRITE THE BLOCK OUT TO THE OUTPUT FILE
POP %RAX
MOV %RAX, %RDX			#BUFFER SIZE (THIRD ARGUMENT)
MOV $SYS_WRITE, %RAX		#WRITE SYSTEM CALL
MOV ST_FD_OUT(%RBP), %RDI	#FILE DESCRIPTOR (FIRST ARGUMENT)
MOV $BUFFER_DATA, %RSI		#BUFFER LOCATION (SECOND ARGUMENT)
SYSCALL				#CALL KERNEL

#CONTINUE THE LOOP
JMP READ_LOOP_BEGIN

END_LOOP:
#CLOSE THE FILES
MOV $SYS_CLOSE, %RAX
MOV ST_FD_OUT(%RBP), %RDI	#OUTPUT FILE DESCRIPTOR
SYSCALL

MOV $SYS_CLOSE, %RAX
MOV ST_FD_IN(%RBP), %RDI	#INPUT FILE DESCRIPTOR
SYSCALL

#EXIT
MOV $SYS_EXIT, %RAX		#EXIT SYSTEM CALL
MOV $0, %RDI			#EXIT STATUS
SYSCALL

#PURPOSE: THIS FUNCTION ACTUALLY DOES THE CONVERSION 
#	  TO UPPERCASE FOR A BLOCK
#
#INPUT:	  FIRST PARAMETER (%RDI) IS THE LENGTH OF THE BUFFER
#	  SECOND PARAMETER (%RSI) IS THE LOCATION OF THE BLOCK OF
#	  MEMORY TO CONVERT
#
#OUTPUT:  THIS FUNCTION OVERWRITES THE CURRENT BUFFER
#	  WITH THE UPPER-CASIFIED VERSION
#
#VARIABLES:
#	  %RSI - BEGINNING OF BUFFER
#	  %RDI - LENGTH OF BUFFER
#	  %RCX - CURRENT BUFFER OFFSET
#	  %AL - CURRENT BYTE BEING EXAMINED

#CONSTANTS
.EQU LOWERCASE_A, 'A'		#LOWER BOUNDARY OF OUR SEARCH
.EQU LOWERCASE_Z, 'Z'		#UPPER BOUNDARY OF OUR SEARCH
.EQU UPPER_CONVERSION, 'A' - 'A'#CONVERSION BETWEEN UPPER AND LOWER CASE

CONVERT_TO_UPPER:
PUSH %RBP
MOV %RSP, %RBP

#SET UP VARIABLES
# %RDI ALREADY CONTAINS BUFFER LENGTH
# %RSI ALREADY CONTAINS BUFFER ADDRESS
MOV $0, %RCX			#INITIALIZE OFFSET TO 0

CMP $0, %RDI			#CHECK IF THE BUFFER LENGTH IS ZERO
JE END_CONVERT_LOOP		#IF SO, JUST LEAVE

CONVERT_LOOP:
MOV (%RSI,%RCX,1), %AL		#GET THE CURRENT BYTE
				#BYTE = (BUFFER_START + OFFSET)

CMP $LOWERCASE_A, %AL		#CHECK IF THE BYTE IS BETWEEN 'A'
JL NEXT_BYTE			#AND 'Z'
CMP $LOWERCASE_Z, %AL		#IF NOT, GO TO NEXT BYTE
JG NEXT_BYTE

ADD $UPPER_CONVERSION, %AL	#CONVERT TO UPPERCASE
MOV %AL, (%RSI,%RCX,1)		#STORE IT BACK INTO BUFFER

NEXT_BYTE:
INC %RCX			#INCREMENT BUFFER OFFSET
CMP %RCX, %RDI			#CONTINUE UNTIL WE HAVE REACHED THE END
JNE CONVERT_LOOP

END_CONVERT_LOOP:
MOV %RBP, %RSP			#NO RETURN VALUE, JUST LEAVE
POP %RBP
RET

# TO RUN: FROM THE COMMAND LINE
# TAKES THE FILE TOUPPER.S, CHANGES ALL LOWERCASE TO UPPERCASE AND SAVES AS A NEW FILE TOUPPER.UPPERCASE
#			AS --64 TOUPPER.S -O TOUPPER.O
#			LD TOUPPER.O -O TOUPPER
#			./TOUPPER TOUPPER.S TOUPPER.UPPERCASE
