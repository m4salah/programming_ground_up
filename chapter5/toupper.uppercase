#PURPOSE: THIS PROGRAM CONVERTS AN INPUT FILE
#	  TO AN OUTPUT FILE WITH ALL LETTERS 
#	  CONVERTED TO UPPERCASE.
#
#PROCESSING: 1) OPEN THE INPUT FILE
#	     2) OPEN THE OUTPUT FILE
#	     3) WHILE WE'RE NOT AT THE END OF THE INPUT FILE
#		A) READ PART OF FILE INTO OUR MEMORY BUFFER
#		B) GO THROUGH EACH B-BIT)
.EQU SYS_READ, 0
.EQU SYS_WRITE, 1
.EQU SYS_OPEN, 2
.EQU SYS_CLOSE, 3
.EQU SYS_EXIT, 60

#OPTIONS FOR OPEN
.EQU O_RDONLY, 0
.EQU O_CREAT_WRONLY_TRUNC, 03101

#STANDARD FILE DESCRIPTORS
.EQU STDIN, 0
.EQU STDOUT, 1
.EQU STDERR, 2

.EQU END_OF_FILE, 0		#RETURN VALUE OF READ WHEN END OF FILE
.EQU NUMBER_ARGUMENTS, 2

.SES BUFFER CALLED BUFFER_DATA
				#WITH SIZE OF 500 BYTES.

.SECTION .TEXT

#STACK POSITIONS (64-BIT OFFSETS)
.EQU ST_SIZE_RESERVE, 16	#RESERVE SPACE FOR 2 QUADWORDS
.EQU ST_FD_IN, -8		#INPUT FILE DESCRIPTOR
.EQU ST_FD_OUT, -16		#OUTPUT FILE DESCRIPTOR
.EQU ST_ARGC, 0			#NUMBER OF ARGUMENTS
.EQU ST_AR %RBP

# ALLOCATE SPACE FOR FILE DESCRIPTORS ON THE STACK
SUB $ST_SIZE_RESERVE, %RSP	#2 QUADWORDS

OPEN_FILES:
OPEN_FD_IN:			#OPEN INPUT FILE
MOV $SYS_OPEN, %RAX		#SYSTEM CALL NUMBER FOR OPEN
MOV ST_ARGV_1(%RBP), %RDI	#FILENAME (FIRST ARGUMENT IN RDI)
MOV $O_RDONLY, %RSI		#FLAGS (SECOND %RDI	#OUTPUT FILENAME
MOV $O_CREAT_WRONLY_TRUNC, %RSI
MOV $0666, %RDX
SYSCALL

STORE_FD_OUT:
MOV %RAX, ST_FD_OUT(%RBP)	#STORE FILE DESCRIPTOR

READ_LOOP_BEGIN:
MOV $SYS_READ, %RAX		#READ SYSTEM CALL
MOV ST_FD_IN(%RBP), %RDI	#FILE DESCRIPTOR (FIRST ARGUMENT)
MOV $BUFFER_DATA, %RSI		#BUFFEOF FILE MARKER
JLE END_LOOP			#IF FOUND OR ON ERROR, GO TO END

CONTINUE_READ_LOOP:
#CONVERT THE BLOCK TO UPPERCASE
MOV %RAX, %RDI			#FIRST ARGUMENT: BUFFER SIZE
MOV $BUFFER_DATA, %RSI		#SECOND ARGUMENT: BUFFER LOCATION
CALL CONVERT_TO_UPPER		#CALL CONVERSION FUNCTION

#WRITE THE BLOCK OUT TO THSECOND ARGUMENT)
SYSCALL				#CALL KERNEL

#CONTINUE THE LOOP
JMP READ_LOOP_BEGIN

END_LOOP:
#CLOSE THE FILES
MOV $SYS_CLOSE, %RAX
MOV ST_FD_OUT(%RBP), %RDI	#OUTPUT FILE DESCRIPTOR
SYSCALL

MOV $SYS_CLOSE, %RAX
MOV ST_FD_IN(%RBP), %RDI	#INPUT FILE DESCRIPTOR
SYSCALL

#EXIT
MOV $SYS_EXIT, %RAX		#EXIT SYSTEM CALL
MOV $0, %RDI			#EXIT STATUSECOND PARAMETER (%RSI) IS THE LOCATION OF THE BLOCK OF
#	  MEMORY TO CONVERT
#
#OUTPUT:  THIS FUNCTION OVERWRITES THE CURRENT BUFFER
#	  WITH THE UPPER-CASIFIED VERSION
#
#VARIABLES:
#	  %RSI - BEGINNING OF BUFFER
#	  %RDI - LENGTH OF BUFFER
#	  %RCX - CURRENT BUFFER OFFSET
#	  %AL - CURRENT BYTE BEING EXAMINED

#CONSTANTASE

CONVERT_TO_UPPER:
PUSH %RBP
MOV %RSP, %RBP

#SET UP VARIABLES
# %RDI ALREADY CONTAINS BUFFER LENGTH
# %RSI ALREADY CONTAINS BUFFER ADDRESS
MOV $0, %RCX			#INITIALIZE OFFSET TO 0

CMP $0, %RDI			#CHECK IF THE BUFFER LENGTH IS ZERO
JE END_CONVERT_LOOP		#IF SO, JUST LEAVE

CONVERT_LOOP:
MOV (%RSI,%RCX,1), %AL		#GET THE CURRENT BYTE
				E
JG NEXT_BYTE

ADD $UPPER_CONVERSION, %AL	#CONVERT TO UPPERCASE
MOV %AL, (%RSI,%RCX,1)		#STORE IT BACK INTO BUFFER

NEXT_BYTE:
INC %RCX			#INCREMENT BUFFER OFFSET
CMP %RCX, %RDI			#CONTINUE UNTIL WE HAVE REACHED THE END
JNE CONVERT_LOOP

END_CONVERT_LOOP:
MOV %RBP, %RSP			#NO RETURN VALUE, JUST LEAVE
POP %RBP
RET

# TO RUN: FROM THE PER.O -O T